import numpy as np
import os
import downing_code.tflowtools as TFT
from datasets.mnist_zip.mnist_basics import gen_flat_cases


class CaseManager():

    def __init__(self, case, minibatch_size, case_fraction, validation_fraction=0, test_fraction=0, number_of_classes=0):
        self.casename = case
        self.casefunc = self.get_case_function(case, number_of_classes)

        self.validation_fraction = validation_fraction
        self.test_fraction = test_fraction
        self.training_fraction = 1 - (validation_fraction + test_fraction)

        self.cases = self.generate_cases()

        if 0 < case_fraction <= 1:
            self.total_case_fraction = case_fraction * len(self.cases)
        else: raise ValueError("case fraction needs to be between 0 and 1.")

        self.organize_cases()

    def get_case_function(self, case, number_of_classes=0):
        # Cases generated by function:
        if case == "one-hot-bit":
            return lambda : TFT.gen_all_one_hot_cases(len=2 ** 4)
        if case == "parity":
            return lambda : TFT.gen_all_parity_cases(num_bits=10, double=True)
        if case == "dense":
            return lambda : TFT.gen_dense_autoencoder_cases(1000, size=10, dr=(0.4, 0.7))
        if case == "bit-counter":
            return lambda : TFT.gen_vector_count_cases(num=500, size=15)
        if case == "segment-counter":
            return lambda : TFT.gen_segmented_vector_cases(count=1000, minsegs=0, maxsegs=8,vectorlen=25)

        # cases generated from file:
        if case == "wine quality":
            return self.file_reader(os.path.join("..","datasets","winequality_red.txt"), number_of_classes)
        if case == "glass":
            return self.file_reader(os.path.join("..","datasets","glass.txt"), number_of_classes)
        if case == "yeast":
            return self.file_reader(os.path.join("..","datasets","yeast.txt"), number_of_classes)
        if case == "mnist":
            return gen_flat_cases

        # TODO: Implement the hacker's choice dataset
        if case == "hackers choice": return None


    def generate_cases(self) -> list:
        """ Run the case generator.  Case = [input-vector, target-vector] """
        return self.casefunc()

    def organize_cases(self):
        ca = np.array(self.cases[:int(self.total_case_fraction)])
        np.random.shuffle(ca) # Randomly shuffle all cases
        separator1 = round(int(self.total_case_fraction) * self.training_fraction)
        separator2 = separator1 + round(int(self.total_case_fraction)*self.validation_fraction)
        self.training_cases = ca[0:separator1]
        self.validation_cases = ca[separator1:separator2]
        self.testing_cases = ca[separator2:]

    def get_training_cases(self): return self.training_cases
    def get_validation_cases(self): return self.validation_cases
    def get_testing_cases(self): return self.testing_cases

    def file_reader(self, file, number_of_classes):
        def read_file():
            raw_data = None
            with open(file, "r") as f:
                raw_data = f.readlines()

            separator = "," if self.casename != "wine quality" else ";"
            cases = []

            # Koden under må gjøre to ting:
            # 1.  Alle verdier for features (venstre verdier) må normalisers etter høyeste verdi.
            # 2.  Må lage one-hot-bit vektor for target (se oppgaveteksten).
            mod = -1 if self.casename in ["glass"] else -2 if self.casename  =="wine quality" else 0

            for item in raw_data:
                # Slicing and dicing the raw input data
                elements = item.strip("\n").split(separator)
                elements = [float(element) for element in elements]

                # Creating a one-hot vector of possible outputs:
                hot_bit = [0]*number_of_classes
                hot_bit[int(elements[-1]) + mod -1] = 1

                # Zipping results.
                cases += [[elements[:-1], hot_bit]]
                del hot_bit
            return cases
        return read_file