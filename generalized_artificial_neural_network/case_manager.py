import numpy as np
import os
import downing_code.tflowtools as TFT
from datasets.mnist_zip.mnist_basics import gen_flat_cases


class CaseManager():

    def get_training_cases(self): return self.training_cases
    def get_validation_cases(self): return self.validation_cases
    def get_testing_cases(self): return self.testing_cases


    def __init__(self, case, normalize, case_fraction, validation_fraction=0, test_fraction=0, number_of_classes=0):
        self.casename = case
        self.case_fraction = case_fraction
        self.validation_fraction = validation_fraction
        self.test_fraction = test_fraction
        self.training_fraction = 1 - (validation_fraction + test_fraction)

        self.casefunc = self._get_case_function(case, number_of_classes, normalize)
        self.cases = self._generate_cases()

        if 0 < case_fraction <= 1 and case != "mnist":
            self.total_case_fraction = case_fraction * len(self.cases)
        else: self.total_case_fraction = len(self.cases)
        self._organize_cases()

    def _get_case_function(self, case, number_of_classes=0, normalize=False):
        # Cases generated by function:
        if case == "one-hot-bit":
            return lambda : TFT.gen_all_one_hot_cases(len=2 ** 4)
        if case == "parity":
            return lambda : TFT.gen_all_parity_cases(num_bits=10, double=True)
        if case == "dense":
            return lambda : TFT.gen_dense_autoencoder_cases(1000, size=10, dr=(0.4, 0.7))
        if case == "bit-counter":
            return lambda : TFT.gen_vector_count_cases(num=500, size=15)
        if case == "segment-counter":
            return lambda : TFT.gen_segmented_vector_cases(count=1000, minsegs=0, maxsegs=8,vectorlen=25)

        # cases generated from file:
        if case == "wine quality":
            return self._file_reader(os.path.join("..", "datasets", "winequality_red.txt"), number_of_classes, normalize)
        if case == "glass":
            return self._file_reader(os.path.join("..", "datasets", "glass.txt"), number_of_classes, normalize)
        if case == "yeast":
            return self._file_reader(os.path.join("..", "datasets", "yeast.txt"), number_of_classes, normalize)
        if case == "mnist":
            def mnist():
                return gen_flat_cases(case_fraction=self.case_fraction)
            return mnist
        # TODO: Implement the hacker's choice dataset
        if case == "hackers choice": return None

    def _generate_cases(self) -> list:
        """ Run the case generator.  Case = [input-vector, target-vector] """
        return self.casefunc()

    def _organize_cases(self):
        ca = np.array(self.cases[:int(self.total_case_fraction)])
        np.random.shuffle(ca) # Randomly shuffle all cases
        separator1 = round(int(self.total_case_fraction) * self.training_fraction)
        separator2 = separator1 + round(int(self.total_case_fraction)*self.validation_fraction)
        self.training_cases = ca[0:separator1]
        self.validation_cases = ca[separator1:separator2]
        self.testing_cases = ca[separator2:]

    def _file_reader(self, file, number_of_classes, normalize=True):
        def read_file():
            raw_data = None
            with open(file, "r") as f:
                raw_data = f.readlines()

            separator = "," if self.casename != "wine quality" else ";"
            cases = []

            # Koden under må gjøre to ting:
            # 1.  Alle verdier for features (venstre verdier) må normalisers etter høyeste verdi.
            # 2.  Må lage one-hot-bit vektor for target (se oppgaveteksten).
            mod = -1 if self.casename in ["glass"] else -2 if self.casename  =="wine quality" else 0

            for item in raw_data:
                # Slicing and dicing the raw input data
                elements = item.strip("\n").split(separator)
                elements = [float(element) for element in elements]

                # Creating a one-hot vector of possible outputs:
                hot_bit = [0]*number_of_classes
                hot_bit[int(elements[-1]) + mod -1] = 1

                # Zipping results.
                cases += [[elements[:-1], hot_bit]]
                del hot_bit

            if not normalize:
                return cases

            normalized = []
            max = 0
            for case in cases:
                for number in case[0]:
                    max = number if number > max else max

            # Normalize:
            for i in range(len(cases)):
                 for j in range(len(cases[i][0])):
                    cases[i][0][j] = cases[i][0][j] / max
            return cases
        return read_file
